#!perl

# hapy_blocks - generate blocks with Hadamard opacities/colors
# @(#) $Id$
# 2025-08-09, Georg Fischer: copied from hapy_empty.pl; *VF=44
#:#
#:# Usage:
#:#   perl hapy_blocks.pl [-d debug] planes.tmp > hapyramid_blocks.js
#:#       -d 0=none, 1=some, 2=more debuging output
#:#       -m max. edge length (default 22)
#----------------
use strict;
use warnings;
use integer;
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime (time);
my $utc_stamp = sprintf ("%04d-%02d-%02dT%02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min);

my $debug = 0;
my $max_edge = 22;
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt  =~ m{d}) {
        $debug     = shift(@ARGV);
    } elsif ($opt  =~ m{e}) {
        $max_edge  = shift(@ARGV);
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt
#--------
# read the matrices
my @planes = ();
my @plane = ( # default planes[0]
 [ 1, 1 ],
 [ 1, 0 ]
);

my $ipla = -1;
while(<>) {
  s/\s+\Z//;
  my $line = $_;
  #                1   1
  if ($line =~ m{\[(\d+)\]}) { # plane header line
    $ipla = $1;
    push(@planes, [@plane]); # previous accumulated plane
    @plane = ();
    #                   1         1
  } elsif ($line =~ m{\A([0-9a-f]+)\Z}) { # line with hex encoding elements
  	my $hex_string = $1;
    my @terms = map {
          hex($_)
        } split(//, $hex_string);
    push(@plane, [@terms]);
  }
} # while <>
push(@planes, [@plane]); # last accumulated plane 
print STDERR scalar(@planes) . " planes read\n";
# exit;
#----
my $displ = 50;
print <<"GFis";
/**
  hapyramid_blocks.js - Coordinates of the blocks for the Hadamard pyramid
  \@(#) \$Id\$
  Generated by hapy_blocks.pl at $utc_stamp
*/  
var displ  = $displ;
var vec_pyramid = 
//   aazzxxyy   aazzxxyy   aazzxxyy   aazzxxyy,  aa=opacity 0..15
GFis

my $sep = "[";
my $incr = 0;
for (my $el = 2; $el <= $max_edge; $el += 2) {
  my $el2 = $el / 2;
  print "\n  // plane 4*$el2\n  "; # start next plane on a new line
  $incr ++; 
  my $y = $displ + $max_edge/4 - $incr;
  for (my $row = 0; $row < $el; $row ++) {
    my $x = - $incr + $row + $displ;
    for (my $col = 0; $col < $el; $col ++) {
      if ($el == $max_edge || $row == 0 || $row == $el - 1 || ($col == 0 || $col == $el - 1)) {
        my $z = - $incr + $col + $displ;
        # my $opac = (($row + $col) % 16) * 6;
        my $opac = $planes[$incr][$row][$col];
        my $block  =  $opac * 1000000 + $z * 10000 + $x * 100 + $y;
        print "$sep" . sprintf("%8d", $block);
        $sep = ",";
      }
    } # for $col
  } # for $row
} # for $el
print <<"GFis";

  ];
GFis
#--------
__DATA__
# planes[1], rowlen=4
ee
e1

  1*"1"  3*"e"

# planes[2], rowlen=8
eeee
e1e1
ee11
e11e

  6*"1"  10*"e"

# planes[3], rowlen=12
eddddd
b8e11e
be8e11
b1e8e1
b11e8e
be11e8

  10*"1"  5*"b"  5*"d"  11*"e"  5*"8"

# planes[4], rowlen=16
eeeeeeee
e1e1e1e1
ee11ee11
e11ee11e
eeee1111
e1e11e1e
ee1111ee
e11e1ee1

  28*"1"  36*"e"
