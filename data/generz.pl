#!/usr/bin/perl
# 2017-08-26, Georg Fischer - Program is in the public domain
# c.f. https://oeis.org/A220952

use strict;
use integer; # avoid division problems with reals

my $debug  = 1; # debugging output level, 0 = none, 1 = some, 2 = most
my $base   = 5; 
my $maxexp = 20;  # compute b-file up to $base**$maxexp
if (scalar(@ARGV) > 0) {
    $maxexp = shift(@ARGV);
}

# It is more efficient to prepare an array with powers of 5:
my $ind = 0;
my $bpow = 1;
my @pow5 = ();
while ($ind <= $maxexp) { 
    $pow5[$ind] = $bpow; # == 5**$ind
    $bpow *= 5;
    $ind ++;
} # while $ind

print "# n a(n) - b-file in OEIS format generated by: perl generz.pl $maxexp\n";
&generz($maxexp, +1, 0, 0, 1);

sub generz { # output one generation
    # caution: recursive!
    # result is coordinate of last node of this generation
    my  ( $exp   # current exponent
        , $diag  # +1 for main diagonal, -1 for anti-diagonal
        , $xoff  # x coordinate of first node
        , $yoff  # y coordinate of first node
        , $last  # 1(0): do (not) output the last node which was output
        ) = @_; 
    print "# generz($exp, $diag, $xoff, $yoff)\n" if $debug >= 1;
    my $x = $xoff;
    my $y = $yoff;
    if (0) {
    } elsif ($exp == 0) {
        &output($x, $y);
    } elsif ($exp == 1) {
        &output($x, $y); $x += $diag; $y += $diag;
        &output($x, $y); $x += $diag; $y += $diag;
        &output($x, $y); $x += $diag; $y += $diag;
        &output($x, $y); $x += $diag; $y += $diag;
        if ($last > 0) {
        	&output($x, $y);
        }
    } else { # exp >=2
        my $exp_1 = $exp - 1;
        ($x, $y) = &generz ($exp_1, + $diag,  0,  0, 0);
        ($x, $y) = &advance($exp_1, + $diag, $x, $y, 4);
        $x -= $diag; $y -= $diag;
        ($x, $y) = &generz ($exp_1, - $diag, $x, $y, 0);
        ($x, $y) = &advance($exp_1, - $diag, $x, $y, 2);
        ($x, $y) = &generz ($exp_1, + $diag, $x, $y, 0);
        ($x, $y) = &advance($exp_1, - $diag, $x, $y, 1);
        ($x, $y) = &generz ($exp_1, - $diag, $x, $y, 0);
        ($x, $y) = &advance($exp_1, + $diag, $x, $y, 4);
        ($x, $y) = &generz ($exp_1, + $diag, $x, $y, $last);
    } # exp > 0
    print "# generz: return ($x,$y)\n" if $debug >= 1;
    return ($x, $y);
} # generz

sub advance { # advance horizontally, maybe fill 2 intermediate positions
    my  ( $exp_1 # gives the distance 
        , $diag  # +1 = to the right, -1 = to the left
        , $xoff  # x coordinate of current node
        , $yoff  # y coordinate of current node
        , $num   # number of positions to advance: 1 or 3
        ) = @_; 
    print "# advance($exp_1, $diag, $xoff, $yoff, $num)\n" if $debug >= 1;
    my $x = $xoff;
    my $y = $yoff;
    my $ind = 0;
    while ($ind < $num) {
        $x += $pow5[$exp_1] * $diag;
        $y += 1;
        if ($ind < $num - 1) {
            &output($x, $y);
        }
        $ind ++;
    } # while $ind
    print "# advance: return ($x, $y)\n" if $debug >= 1;
    return ($x, $y);
} # shift

sub output { # output one node in b-file format
    my  ( $x   # horizontal coordiante
        , $y   # vertical   coordinate
        ) = @_; 
    print "$y $x\n";
} # output
__DATA__
