==Abstract==
With the operations defined by Collatz for his ''3x + 1'' problem, two sets of special, finite trees are constructed. It is shown that these trees contain all numbers, and that the can be combined to form bigger trees by an iterative process. This process is repeated on four levels, until it is finally shown that all remaining trees can be combined into one tree which contains all natural numbers, and which is free of cycles (except for the cycle 4-2-1).
==Introduction==
'''Collatz sequences''' (also called  ''trajectories'') are sequences of integer numbers &gt; 0. For some start value &gt; 0 the elements of a particular sequence are constructed with two simple rules:
# Even numbers are halved.
# Odd numbers are multiplied by 3 and then incremented by 1.
Since decades it is unknown whether the final cyle 4 - 2 - 1 is always reached for all start values. This problem is the '''Collatz conjecture''', for which the [https://en.wikipedia.org/wiki/Collatz_conjecture English Wikipedia] states:
: It is also known as the 3n + 1 conjecture, the Ulam conjecture (after Stanis&#x0142;aw Ulam), Kakutani's problem (after Shizuo Kakutani), the Thwaites conjecture (after Sir Bryan Thwaites), Hasse's algorithm (after Helmut Hasse), or the Syracuse problem; the sequence of numbers involved is referred to as the hailstone sequence or hailstone numbers (because the values are usually subject to multiple descents and ascents like hailstones in a cloud), or as wondrous numbers.

Simple visualizations of Collatz sequences show no obvious structure. The sequences for the first dozen of start values are rather short, but the sequence for 27 suddenly has 112 elements.
<p align="right">''Da sieht man den Wald vor lauter B&auml;men nicht.''<br />German proverb: ''You cannot see the wood for the trees.''
</p>
===References===
* Jeffry C. Lagarias, Ed.: ''The Ultimate Challenge: The 3x+1 Problem'', Amer. Math. Soc., 2010, ISBN 978-8218-4940-8. [http://www.ams.org/bookpages/mbk-78 MBK78]
* OEIS A07165: [http://oeis.org/A070165/a070165.txt  File of first 10K Collatz sequences], ascending start values, with lengths
* Manfred Tr&uuml;mper: ''The Collatz Problem in the Light of an Infinite Free Semigroup''. Chinese Journal of Mathematics, Vol. 2014, [http://dx.doi.org/10.1155/2014/756917 Article ID 756917], 21 p.

==Collatz Graph==
When all Collatz sequences are read backwards, they form the '''Collatz graph''' starting with 1, 2, 4, 8 ... . At each node ''n &gt; 4'' in the graph, the path from the root (4) can be continued
* always to ''n * 2'', and
* to ''(n - 1) / 3'' if ''n &#x2261; 1 mod 3''.

The Collatz conjecture claims that the Collatz graph
* contains all numbers,
and that it - except for the leading cycle 1 - 2 - 4 - 1 - 2 - 4 ... -
* has the form of a tree (without cycles).
We will not consider the leading cycle, and we start the graph with node 4, the '''root'''.
Furthermore we observe that a path can be continued with duplications only once it reaches a node ''n &#x2261; 0 mod 3''. We omit these trivial continuations.
===Graph Operations===
Following [http://dx.doi.org/10.1155/2014/756917 Tr&uuml;mper], we use abbreviations for the elementary '''operations''' which map a node (element, number) ''n'' in the Collatz graph to the a neighbouring node as shown in the following table (T1):
{| class="wikitable" style="text-align:center"
!Name     !! Mnemonic    !! Distance to root  !! Mapping                    !! Condition
|-
| d       || "down"      || -1                || n &#x21a6; n / 2           || n &#x2261; 0 mod 2
|-
| u       || "up"        || -1                || n &#x21a6; 3 * n + 1       || (none)
|-
| s := ud || "spike"     || -2                || n &#x21a6; (3 * n + 1) / 2)|| n &#x2261; 1 mod 2
|-
| &delta; || "divide"    || +1                || n &#x21a6; (n - 1) / 3     || n &#x2261; 1 mod 3
|-
| &micro; || "multiply"  || +1                || n &#x21a6; n * 2           || (none)
|-
| &sigma; := &delta;&micro;|| "squeeze" || +2 ||n &#x21a6; ((n - 1) / 3) * 2|| n &#x2261; 1 mod 3
|}
The operations will be noted as ''infix'' operators, with the source node as left operand and the target node as right operand, for example ''10 &delta;&micro; 6''. In the following, we will mainly be interested in the reverse mappings (denoted with greek letters) which move away from the root 4 of the graph.

===Motivation: Patterns in sequences with the same length===
A closer look at the Collatz sequences shows a lot of pairs of adjacent start values which have the same sequence length, for example (from [https://oeis.org/A070165 OEIS A070165]):
 142/104: 142 d  71 u 214 d 107 u 322 d 161 u 484 d  242 d 121 u 364 ] d 182 ... 4 d 2 d 1
 143/104: 143 u 430 d 215 u 646 d 323 u 970 d 485 u 1456 d 728 d 364 ] d 182 ... 4 d 2 d 1
The alternating pattern of operations can be continued to the left with additional pairs of steps:
  n? u [ 62 d  31 u  94 d  47 u 142 d ...
 126 d [ 63 u 190 d  95 u 286 d 143 u ...
The pattern stops here since there is no integer ''n'' such that ''n * 3 + 1 = 62''.
Beginning at some node (364 &#x2261; 4 mod 6 in the example), these sequences join and follow the same path down to the root 4. The two differing parts of the sequences show a regular pattern. Proceeding from right to left, and thereby using the inverse operations, we see the following operations (example (E1)):
 364 &delta; 121 &micro;  242 &micro; 484 &delta; 161 &micro; 322 &delta; 107 &micro; 214 &delta;  71 &micro; 142 &delta;  47 &micro;  94 &delta;  31 &micro; 62
 364 &micro; 728 &micro; 1456 &delta; 485 &micro; 970 &delta; 323 &micro; 646 &delta; 215 &micro; 430 &delta; 143 &micro; 286 &delta;  95 &micro; 190 &delta; 63

==Segments==
These patterns lead us to the construction of special subsets of paths in the Collatz graph which we call '''segments'''. Starting at some node ''n &#x2261; 4 mod 6'', the ''fork'', two subpaths lead away from the root in a prescribed, finite sequence of operations.
:The nodes ''n &#x2261; 4 mod 6'' play a special role because they are the only ones for which both a &delta; and a &micro; operation is possible.

===Segment Construction Rules===
Informally, the segments are constructed beginning at the fork with a few differing operations, followed by a sequence of &sigma; operations in both subpaths.

The segment construction process stops when the next node in one of the two subpaths becomes divisible by 3, i.e. when a &delta; (resp. &sigma;) operation is no more possible. We will show that this is always the case.

===&sigma; replaces 3 by 2===
The &sigma; operation, when applied to fork nodes of the form ''6i - 2'' with ''i = 3k'', has the interesting property that it maintains the general form ''6n - 2'':
 6(3k) - 2 &sigma; (2(3k) - 1) * 2 = 12k - 2 = 6(2k) - 2
That means that &sigma; replaces one factor 3 by a factor 2 (it "squeezes" a 3 into a 2). In the opposite direction, the ''s ("spike")'' operation replaces one factor 2 in ''i'' by a factor 3.
In the same way we could have used the form ''6n + 4'' with ''i = 3k - 1'':
 6(3k - 1) + 4 &sigma; (2 * (3k - 1) + 1) * 2 = 12k - 4 + 2 = 6(2k - 1) + 4
Whether the resulting formulas are more simple may be a matter of taste. We use the previous form ''6n - 2'' in the rest of this article.

With this property it is easy to state:
* (S??) For any possible fork node, the corresponding segment is of finite length.
:: The length of the segment is proportional to the power of 3 contained in the factor ''i'' of the fork node, which is finite.

===Segment Directory Construction===
For the presentation of various properties of the segments, we use a linearized notation of the two subpaths. 
We list the segments for all possible fork nodes of the form ''6i - 2, i &gt; 0'' as rows of an infinite array ''<nowiki>C[i, j]</nowiki>'' which we call the '''segment directory'''. 

The following table '''(T2)''' tells how the columns ''j'' in one row ''i'' of ''C'' must be constructed if the condition is fulfilled: 
{| class="wikitable" style="text-align:left"
!Column j               !! Operation                   !! Formula                  !! Condition            !! First elements
|-
| 1 || <nowiki>C[i, 1]</nowiki>                        ||  6 * i - 2               ||                      ||  4, 10, 16, 22, 28 ...
|-
| 2 || <nowiki>C[i, 1]</nowiki> &micro;&micro;         || 24 * (i - 1) / 1     + 16||                      || 16, 40, 64, 88, 112 ...
|-                                                                            
| 3 || <nowiki>C[i, 1]</nowiki> &delta;&micro;&micro;  || 24 * (i - 1) / 3     +  4|| i &#x2261; 1 mod 3   ||  4, 28, 52, 76, 100 ...
|-                                                                            
| 4 || <nowiki>C[i, 2]</nowiki> &sigma;                || 48 * (i - 1) / 3     + 10|| i &#x2261; 1 mod 3   || 10, 58, 106, 134 ...
|-                                                                            
| 5 || <nowiki>C[i, 3]</nowiki> &sigma;                || 48 * (i - 7) / 9     + 34|| i &#x2261; 7 mod 9   || 34, 82, 130, 178 ...
|-                                                                            
| 6 || <nowiki>C[i, 4]</nowiki> &sigma;                || 96 * (i - 7) / 9     + 70|| i &#x2261; 7 mod 9   || 70, 166, 262, 358 ...
|-                                                                            
| 7 || <nowiki>C[i, 5]</nowiki> &sigma;                || 96 * (i - 7) / 27    + 22|| i &#x2261; 7 mod 27  || 22, 118, 214, 310 ...
|-                                                                            
| 8 || <nowiki>C[i, 6]</nowiki> &sigma;                ||192 * (i - 7) / 27   + 46 || i &#x2261; 7  mod 27 || 46, 238, 430, 622 ...
|-
| 9 || <nowiki>C[i, 7]</nowiki> &sigma;                ||192 * (i - 61) / 81 + 142 || i &#x2261; 61 mod 81 || 142, 334 ...
|-
|...|| ... || ... || ... || ...
|-
| j || <nowiki>C[i, j-2]</nowiki> &sigma;              || 6 * 2<sup>k+1</sup> * (i - m) / 3<sup>l</sup> + 3 * 2<sup>k</sup> * h - 2 || i &#x2261; m mod 3<sup>l</sup> || ...
|-
|}
The general formula for a column ''j >= 4'' uses the following parameters:
* ''k = floor(j / 2)'' 
* ''l = floor(j - 1) / 2)'' 
* ''m = a(floor((j - 1) / 4)'',  where ''a(n)'' is the OEIS sequence ([http://oeis.org/A066443 A066443]: ''a(0) = 1; a(n) = 9 * a(n-1) - 2 for n &gt; 0'' . The values are the indexes 1, 7, 61, 547, 4921 ... of the variable length segments with left sides (4), 40, 364, 3280, 29524 ([http://oeis.org/A191681 OEIS A191681]). The constants appear first in columns 2-4 (in segment 1), 5-8 (in segment 7), 9-12 (in segment 61) and so on 
* ''h = a(j)'', where ''a(n)'' is the OEIS sequence [http://oeis.org/A084101 A084101] with period 4: ''a(0..3) = 1, 3, 3, 1; a(n) = a(n - 4) for n &gt; 3''.
(This results in ''k = 2, l = 1, m = 1, h = 1 for j = 4''.)

The following example (E2) shows the first few lines of the segment directory, together with the segment for 364 from example (E1) above:
{{Collatz_exam2}}
There is a more elaborated '''[http://www.teherba.org/fasces/oeis/collatz/comp.html segment directory]''' with several thousand rows.

The segment directory contains an infinite number of little subtrees from which we aim to build the single Collatz tree.
===Left Side and Right Part===
The first column(s) ''<nowiki>C[i, 1]</nowiki>'' will be denoted as the '''left side''' of the segments (or of the whole directory), while the columns ''<nowiki>C[i, j], j &gt; 4</nowiki>'' are called the '''right part'''.
====Properties of the Segment Directory====
We make a number of claims for the segment directory C:
* (C1) All nodes in the segment directory have the form ''6n - 2''.
:: This follows from the formula for columns ''<nowiki>C[i, 1..3]</nowiki>'', and for any higher column numbers from the 3-by-2 replacement property of the &sigma; operation.
* (C2) All segments have a finite length.
:: At some point the &sigma; operations will have replaced all factors 3 by 2.
* (C3) All nodes in the right part of a segment have the form ''6(3<sup>n</sup> * 2<sup>m</sup> * f) - 2'' with the same "3-2-free" factor ''f''.
:: This follows from the operations for columns <nowiki>C[i, 1..3]</nowiki>, and from the fact that the &sigma; operation maintains this property.
* (C4) All nodes in the right part of a particular segment are
** different among themselves, and
** different from the left side of that segment (except for the first segment for the root 4).
:: For ''<nowiki>C[i, 1..2]</nowiki>'' we see that the values modulo 24 are different. For the remaining columns, we see that the exponents of the factors 2 and 3 are different. They are shifted by the &sigma; operations, but they alternate, for example (in the segment with left part 40):
 160 = 6 * (3<sup>3</sup> * 2<sup>0</sup> * 1) - 2
  52 = 6 * (3<sup>2</sup> * 2<sup>0</sup> * 1) - 2
 106 = 6 * (3<sup>2</sup> * 2<sup>1</sup> * 1) - 2
  34 = 6 * (3<sup>1</sup> * 2<sup>1</sup> * 1) - 2
  70 = 6 * (3<sup>1</sup> * 2<sup>2</sup> * 1) - 2
  22 = 6 * (3<sup>0</sup> * 2<sup>2</sup> * 1) - 2
  46 = 6 * (3<sup>0</sup> * 2<sup>3</sup> * 1) - 2
* (C5) There is no cycle in a segment (except for the first segment for the root 4).
* (C??) There is no limit on the length of a segment.
:: We only need to take a segment which, in its right part, has a factor of 3 with a sufficiently high power, and the &sigma; operations will stretch out the segment accordingly.

==Coverage==
===Coverage of Non-Forks===
We now show that
* (C??) All numbers ''n &gt; 0'' are either forks (4 mod 6), or there is a unique path from a fork to ''n''. 
Table (T5) shows the residues modulo 6 For some fork (source) node ''n = 6i - 2'':
{| class="wikitable" style="text-align:left"
|-
!  Source       !!Operation     !! Target  !!Reached<br>Nodes!! Remaining<br>Nodes
|-                                  
|  6i - 2       ||(none)        || 6i - 2  ||4 mod 6         || 0, 1, 2, 3, 5 mod 6
|-                                                               
|  6i - 2       ||&delta;       || 2i - 1  ||1, 3, 5 mod 6   || 0, 2, 6, 8 mod 12
|-                                                               
|  6(3k + 1) - 2||&delta;&micro;|| 12k + 2 ||2 mod 12        || 0, 6, 8 mod 12
|-                                                               
|  6i - 2       ||&micro;       || 12i - 4 ||8 mod 12        || 0 mod 6      
|-                                                               
|}
The second row reaches all odd multiples of 3. The remaining multiples of 6 can be reached from there by a &micro; operation.
* (C??) There is only one subpath from some fork to a specific non-fork.

===Coverage of Forks===
We want to show:
* (C??) Any fork node of the form ''6n - 2'' occurs exactly 
** once in the left side and 
** once in the right part of the segment directory.
** There is a bijective mapping between the left sides and the elements of the right parts.
The nodes in the left side are different by the construction of the segment directory. The following table (T3) shows the uniqueness in the columns of the right part. The sequence in one specific column has a particular modulus condition which is different from the ones in all other columns. Therefore the columns all contain disjoint sets of numbers:
{| class="wikitable" style="text-align:left"
!Column  j !!  Operation                     !! Expression           !! Covered        !! Remaining
|-                                                        
| 1||                                        || n = 6i - 2           || (none)         || 4, 10, 16, 22 mod 24     
|-                                                        
| 2|| &micro;&micro;                         || 24i - 8              || 16 mod 24      || 4, 10, 22 mod 24
|-                                                
| 3|| &delta;&micro;&micro;                  || 8i - 4, i = 3k + 1   || 4 mod 24       || 10, 22, 34, 46 mod 48
|-                                                
| 4|| &micro;&micro;&sigma<sup>1</sup>       ||                      || 10 mod 48      || 22, 34, 46 mod 48
|-                                                
| 5|| &delta;&micro;&micro;&sigma<sup>1</sup>||                      || 34 mod 48      || 22, 46, 70, 94 mod 96
|-                                                
| 6|| &micro;&micro;&sigma<sup>2</sup>       ||                      || 70 mod 96      || 22, 46, 94 mod 96 
|-                                                
| 7|| &delta;&micro;&micro;&sigma<sup>2</sup>||                      || 22 mod 96      || 46, 94, 142, 190 mod 192
|-                                                
| 8|| &micro;&micro;&sigma<sup>3</sup>       ||                      || 46 mod 96      || 94, 142, 190 mod 192
|-                                                
| 9|| &delta;&micro;&micro;&sigma<sup>3</sup>||                      || 142 mod 192    || 94, 190, 286, 382 mod 384
|-                                                
|10|| &micro;&micro;&sigma<sup>4</sup>       ||                      || 94 mod 192     || 190, 286, 382 mod 384  
|-                                                
|11|| &delta;&micro;&micro;&sigma<sup>4</sup>||                      || 190 mod 192    || 286, 382, 670, 766 mod 768
|-                                                                                                                     
|...|| ...                                   ||...                   || ...            || ...   
|}
We can always exclude one of the elements remaining so far by looking in the next column of segments with sufficient length.

===Degree 2===
* All supernodes with odd ''i'' follow rules 5 or 6.
* All other source rows either are a supernode, follow a rule 5 or 6, or their target is a supernode.
* If the target is a supernode, then ''k'' is odd.
